[
  {
    "objectID": "shell.html",
    "href": "shell.html",
    "title": "shell",
    "section": "",
    "text": "from fastcore.test import *\nfrom base64 import b64decode\nfrom io import BytesIO\nfrom PIL import Image\n\n\nsource\n\nCaptureShell\n\n CaptureShell (path:str|Path=None)\n\nExecute the IPython/Jupyter source code\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nstr | Path\nNone\nAdd path to python path\n\n\n\n\ns = CaptureShell()\n\n\nsource\n\n\nCaptureShell.run\n\n CaptureShell.run (code:str, stdout=True, stderr=True)\n\nRun code, returning a list of all outputs in Jupyter notebook format\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncode\nstr\n\nPython/IPython code to run\n\n\nstdout\nbool\nTrue\nCapture stdout and save as output?\n\n\nstderr\nbool\nTrue\nCapture stderr and save as output?\n\n\n\n\ns.run(\"print(1)\")\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']}]\n\n\nCode can include magics and ! shell commands:\n\ns.run(\"%time 1+1\")\n\n[{'name': 'stdout',\n  'output_type': 'stream',\n  'text': ['CPU times: user 3 us, sys: 0 ns, total: 3 us\\n',\n   'Wall time: 5.72 us\\n']},\n {'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 1}]\n\n\nThe result of the last successful execution is stored in result:\n\ns.result\n\n2\n\n\nA trailing ; stops the result from being captured:\n\ns.run(\"1+2;\")\n\n[]\n\n\nImages and matplotlib figures are captured and base64 encoded:\n\nres = s.run('''import matplotlib.pyplot as plt\nplt.figure(figsize=(1,1))\nplt.plot([1,2])''')\n\nImage.open(BytesIO(b64decode(res[1]['data']['image/png'])))\n\n\n\n\nIf an exception is raised then the exception type, object, and stacktrace are stored in exc:\n\ns.run('raise Exception(\"Oops\")')\ntyp,obj,st = s.exc\ntyp,obj\n\n(Exception, Exception('Oops'))\n\n\n\nprint(st)\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nInput In [1], in &lt;cell line: 1&gt;()\n----&gt; 1 raise Exception(\"Oops\")\n\nException: Oops\n\n\n\nsource\n\n\nCaptureShell.cell\n\n CaptureShell.cell (cell, stdout=True, stderr=True)\n\nRun cell, skipping if not code, and store outputs back in cell\n\nclean = Path('../tests/clean.ipynb')\nnb = read_nb(clean)\nc = nb.cells[1]\nc\n\n{ 'cell_type': 'code',\n  'execution_count': None,\n  'id': 'b123d6d0',\n  'idx_': 1,\n  'metadata': {},\n  'outputs': [],\n  'source': 'print(1)\\n2'}\n\n\n\ns.cell(c)\nc.outputs\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']},\n {'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 3}]\n\n\n\nsource\n\n\nCaptureShell.run_all\n\n CaptureShell.run_all (nb, exc_stop:bool=False,\n                       preproc:collections.abc.Callable=&lt;function _false&gt;,\n                       postproc:collections.abc.Callable=&lt;function\n                       _false&gt;, inject_code:Optional[str]=None,\n                       inject_idx:int=0)\n\nRun all cells in nb, stopping at first exception if exc_stop\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnb\n\n\nA notebook read with nbclient or read_nb\n\n\nexc_stop\nbool\nFalse\nStop on exceptions?\n\n\npreproc\nCallable\n_false\nCalled before each cell is executed\n\n\npostproc\nCallable\n_false\nCalled after each cell is executed\n\n\ninject_code\nstr | None\nNone\nCode to inject into a cell\n\n\ninject_idx\nint\n0\nCell to replace with inject_code\n\n\n\n\nnb.cells[2].outputs\n\n[]\n\n\n\ns.run_all(nb)\nnb.cells[2].outputs\n\n[{'data': {'text/plain': ['&lt;IPython.core.display.Markdown object&gt;'],\n   'text/markdown': [\"This is *bold*. Here's a [link](https://www.fast.ai).\"]},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 6}]\n\n\nWith exc_stop=False (the default), execution continues after exceptions, and exception details are stored into the appropriate cellâ€™s output:\n\nnb.cells[-1].source\n\n'raise Exception(\"Oopsie!\")'\n\n\n\nnb.cells[-1].outputs\n\n[{'ename': \"&lt;class 'Exception'&gt;\",\n  'evalue': 'Oopsie!',\n  'output_type': 'error',\n  'traceback': ['\\x1b[0;31m---------------------------------------------------------------------------\\x1b[0m',\n   '\\x1b[0;31mException\\x1b[0m                                 Traceback (most recent call last)',\n   'Input \\x1b[0;32mIn [1]\\x1b[0m, in \\x1b[0;36m&lt;cell line: 1&gt;\\x1b[0;34m()\\x1b[0m\\n\\x1b[0;32m----&gt; 1\\x1b[0m \\x1b[38;5;28;01mraise\\x1b[39;00m \\x1b[38;5;167;01mException\\x1b[39;00m(\\x1b[38;5;124m\"\\x1b[39m\\x1b[38;5;124mOopsie!\\x1b[39m\\x1b[38;5;124m\"\\x1b[39m)\\n',\n   '\\x1b[0;31mException\\x1b[0m: Oopsie!']}]\n\n\nWith exc_stop=True (the default), exceptions in a cell are raised and no further processing occurs:\n\ntry: s.run_all(nb, exc_stop=True)\nexcept Exception as e: print(f\"got exception: {e}\")\n\ngot exception: Oopsie!\n\n\nWe can pass a function to preproc to have it run on every cell. It can modify the cell as needed. If the function returns True, then that cell will not be executed. For instance, to skip the cell which raises an exception:\n\nnb = read_nb(clean)\ns.run_all(nb, preproc=lambda c: 'raise' in c.source)\n\nThis cell will contain no output, since it was skipped.\n\nnb.cells[-1].outputs\n\n[]\n\n\n\nnb.cells[1].outputs\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']},\n {'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 11}]\n\n\nYou can also pass a function to postproc to modify a cell after it is executed.\n\nsource\n\n\nCaptureShell.execute\n\n CaptureShell.execute (src:Union[str,pathlib.Path],\n                       dest:Optional[str]=None, exc_stop:bool=False,\n                       preproc:collections.abc.Callable=&lt;function _false&gt;,\n                       postproc:collections.abc.Callable=&lt;function\n                       _false&gt;, inject_code:Optional[str]=None,\n                       inject_path:Union[str,pathlib.Path,NoneType]=None,\n                       inject_idx:int=0)\n\nExecute notebook from src and save with outputs to `dest\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsrc\nstr | Path\n\nNotebook path to read from\n\n\ndest\nstr | None\nNone\nNotebook path to write to\n\n\nexc_stop\nbool\nFalse\nStop on exceptions?\n\n\npreproc\nCallable\n_false\nCalled before each cell is executed\n\n\npostproc\nCallable\n_false\nCalled after each cell is executed\n\n\ninject_code\nstr | None\nNone\nCode to inject into a cell\n\n\ninject_path\nstr | Path | None\nNone\nPath to file containing code to inject into a cell\n\n\ninject_idx\nint\n0\nCell to replace with inject_code\n\n\n\nThis is a shortcut for the combination of read_nb, CaptureShell.run_all, and write_nb.\n\ns = CaptureShell()\ntry:\n    s.execute(clean, 'tmp.ipynb')\n    print(read_nb('tmp.ipynb').cells[1].outputs)\nfinally: Path('tmp.ipynb').unlink()\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']}, {'data': {'text/plain': ['2']}, 'execution_count': 2, 'metadata': {}, 'output_type': 'execute_result'}]\n\n\n\np = Path.home()/'git'/'fastcore'/'nbs'\nn = p/'03a_parallel.ipynb'\n\n\nsource\n\n\nCaptureShell.prettytb\n\n CaptureShell.prettytb (fname:Union[str,pathlib.Path]=None)\n\nShow a pretty traceback for notebooks, optionally printing fname.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfname\nstr | Path\nNone\nfilename to print alongside the traceback\n\n\n\nIf an error occurs while running a notebook, you can retrieve a pretty version of the error with the prettytb method:\n\ns = CaptureShell()\ntry:\n    s.execute('../tests/error.ipynb', exc_stop=True)\nexcept:\n    print(s.prettytb())\n\nAssertionError in ../tests/error.ipynb:\n===========================================================================\n\nWhile Executing Cell #2:\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\nInput In [1], in &lt;cell line: 3&gt;()\n      1 # some comments\n      2 print('hello')\n----&gt; 3 foo()\n\nFile ~/git/execnb/tests/err.py:2, in foo()\n      1 def foo():\n----&gt; 2     assert 13 == 98\n\nAssertionError: \n\n\n\nIf you pass inject_code to CaptureShell.execute or CaptureShell.run_all, the source of nb.cells[inject_idx] will be replaced with inject_code. By default, the first cell is replaced. For instance consider this notebook:\n\nnb = read_nb('../tests/params.ipynb')\nfor c in nb.cells: print('- ',c.source)\n\n-  a=1\n-  print(a)\n\n\nWe can replace the first cell with a=2 by passing that as inject_code, and the notebook will run with that change:\n\nnb = read_nb('../tests/params.ipynb')\ns.run_all(nb, inject_code=\"a=2\")\nlist(nb.cells)\n\n[{'cell_type': 'code',\n  'execution_count': 1,\n  'id': 'a63ce885',\n  'metadata': {},\n  'outputs': [],\n  'source': 'a=2',\n  'idx_': 0},\n {'cell_type': 'code',\n  'execution_count': 2,\n  'id': 'ea528db5',\n  'metadata': {},\n  'outputs': [{'name': 'stdout', 'output_type': 'stream', 'text': ['2\\n']}],\n  'source': 'print(a)',\n  'idx_': 1}]\n\n\nThis can be used with CaptureShell.execute to parameterise runs of models in notebooks. Place any defaults for configuration code needed in the first cell, and then when running execute pass in new parameters as needed in inject_code. To replace only some of the defaults, leave an empty cell as the second cell, and inject code using inject_idx=1 to replace the empty second cell with code that overrides some of the defaults set in the first cell. When using execute you can pass inject_path instead of inject_code to read the injected code from a file.\n\nsource\n\n\nexec_nb\n\n exec_nb (src:str, dest:str='', exc_stop:bool=False, inject_code:str=None,\n          inject_path:str=None, inject_idx:int=0)\n\nExecute notebook from src and save with outputs to dest\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsrc\nstr\n\nNotebook path to read from\n\n\ndest\nstr\n\nNotebook path to write to\n\n\nexc_stop\nbool\nFalse\nStop on exceptions?\n\n\ninject_code\nstr\nNone\nCode to inject into a cell\n\n\ninject_path\nstr\nNone\nPath to file containing code to inject into a cell\n\n\ninject_idx\nint\n0\nCell to replace with inject_code\n\n\n\nThis is the command-line version of CaptureShell.execute. Run exec_nb -h from the command line to see how to pass arguments. If you donâ€™t pass dest then the output notebook wonâ€™t be saved; this is mainly useful for running tests."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "execnb",
    "section": "Install",
    "text": "Install\nEither:\npip install execnb\nor if you use conda:\nconda install -c fastai execnb\n(You can replace conda with mamba in the line above if you have mamba installed.)"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "execnb",
    "section": "How to use",
    "text": "How to use\nUse CaptureShell to run Jupyter code and capture notebook outputs, without running a Jupyter server (or even having it installed):\n\nfrom execnb.nbio import *\nfrom execnb.shell import *\nfrom fastcore.utils import *\n\n\ns = CaptureShell()\ns.run('1+1')\n\n[{'data': {'text/plain': ['2']},\n  'metadata': {},\n  'output_type': 'execute_result',\n  'execution_count': 1}]\n\n\nTo execute a notebook and save it with outputs filled in, use CaptureShell.execute:\n\ntry:\n    s.execute('../tests/clean.ipynb', 'tmp.ipynb')\n    print(read_nb('tmp.ipynb').cells[1].outputs)\nfinally: Path('tmp.ipynb').unlink()\n\n[{'name': 'stdout', 'output_type': 'stream', 'text': ['1\\n']}, {'data': {'text/plain': ['2']}, 'execution_count': 3, 'metadata': {}, 'output_type': 'execute_result'}]\n\n\nYou can also execute notebooks from the command line with exec_nb:\n\n!exec_nb --help\n\nusage: exec_nb [-h] [--dest DEST] [--exc_stop] [--inject_code INJECT_CODE]\n               [--inject_path INJECT_PATH] [--inject_idx INJECT_IDX]\n               src\n\nExecute notebook from `src` and save with outputs to `dest`\n\npositional arguments:\n  src                        Notebook path to read from\n\noptional arguments:\n  -h, --help                 show this help message and exit\n  --dest DEST                Notebook path to write to (default: )\n  --exc_stop                 Stop on exceptions? (default: False)\n  --inject_code INJECT_CODE  Code to inject into a cell\n  --inject_path INJECT_PATH  Path to file containing code to inject into a cell\n  --inject_idx INJECT_IDX    Cell to replace with `inject_code` (default: 0)"
  },
  {
    "objectID": "nbio.html",
    "href": "nbio.html",
    "title": "nbio",
    "section": "",
    "text": "A notebook is just a json file.\n\ndef _read_json(self, encoding=None, errors=None):\n    return loads(Path(self).read_text(encoding=encoding, errors=errors))\n\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal_txt = AttrDict(_read_json(minimal_fn))\n\nIt contains two sections, the metadataâ€¦:\n\nminimal_txt.metadata\n\n{'kernelspec': {'display_name': 'Python 3 (ipykernel)',\n  'language': 'python',\n  'name': 'python3'}}\n\n\nâ€¦and, more importantly, the cells:\n\nminimal_txt.cells\n\n[{'cell_type': 'markdown',\n  'metadata': {},\n  'source': ['## A minimal notebook']},\n {'cell_type': 'code',\n  'execution_count': None,\n  'metadata': {},\n  'outputs': [{'data': {'text/plain': ['2']},\n    'execution_count': None,\n    'metadata': {},\n    'output_type': 'execute_result'}],\n  'source': ['# Do some arithmetic\\n', '1+1']}]\n\n\nThe second cell here is a code cell, however it contains no outputs, because it hasnâ€™t been executed yet. To execute a notebook, we first need to convert it into a format suitable for nbclient (which expects some dict keys to be available as attrs, and some available as regular dict keys). Normally, nbformat is used for this step, but itâ€™s rather slow and inflexible, so weâ€™ll write our own function based on fastcoreâ€™s handy dict2obj, which makes all keys available as both attrs and keys.\n\nsource\n\n\n\n NbCell (idx, cell)\n\ndict subclass that also provides access to keys as attrs\nWe use an AttrDict subclass which has some basic functionality for accessing notebook cells.\n\nsource\n\n\n\n\n dict2nb (js=None, **kwargs)\n\nConvert dict js to an AttrDict,\nWe can now convert our JSON into this nbclient-compatible format, which pretty prints the source code of cells in notebooks.\n\nminimal = dict2nb(minimal_txt)\ncell = minimal.cells[1]\ncell\n\n{ 'cell_type': 'code',\n  'execution_count': None,\n  'idx_': 1,\n  'metadata': {},\n  'outputs': [ { 'data': {'text/plain': ['2']},\n                 'execution_count': None,\n                 'metadata': {},\n                 'output_type': 'execute_result'}],\n  'source': '# Do some arithmetic\\n1+1'}\n\n\nThe abstract syntax tree of source code cells is available in the parsed_ property:\n\ncell.parsed_(), cell.parsed_()[0].value.op\n\n([&lt;ast.Expr&gt;], &lt;ast.Add&gt;)\n\n\n\nsource\n\n\n\n\n read_nb (path)\n\nReturn notebook at path\nThis reads the JSON for the file at path and converts it with dict2nb. For instance:\n\nminimal = read_nb(minimal_fn)\nstr(minimal.cells[0])\n\n\"{'cell_type': 'markdown', 'metadata': {}, 'source': '## A minimal notebook', 'idx_': 0}\"\n\n\nThe file name read is stored in path_:\n\nminimal.path_\n\n'../tests/minimal.ipynb'"
  },
  {
    "objectID": "nbio.html#reading-a-notebook",
    "href": "nbio.html#reading-a-notebook",
    "title": "nbio",
    "section": "",
    "text": "A notebook is just a json file.\n\ndef _read_json(self, encoding=None, errors=None):\n    return loads(Path(self).read_text(encoding=encoding, errors=errors))\n\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal_txt = AttrDict(_read_json(minimal_fn))\n\nIt contains two sections, the metadataâ€¦:\n\nminimal_txt.metadata\n\n{'kernelspec': {'display_name': 'Python 3 (ipykernel)',\n  'language': 'python',\n  'name': 'python3'}}\n\n\nâ€¦and, more importantly, the cells:\n\nminimal_txt.cells\n\n[{'cell_type': 'markdown',\n  'metadata': {},\n  'source': ['## A minimal notebook']},\n {'cell_type': 'code',\n  'execution_count': None,\n  'metadata': {},\n  'outputs': [{'data': {'text/plain': ['2']},\n    'execution_count': None,\n    'metadata': {},\n    'output_type': 'execute_result'}],\n  'source': ['# Do some arithmetic\\n', '1+1']}]\n\n\nThe second cell here is a code cell, however it contains no outputs, because it hasnâ€™t been executed yet. To execute a notebook, we first need to convert it into a format suitable for nbclient (which expects some dict keys to be available as attrs, and some available as regular dict keys). Normally, nbformat is used for this step, but itâ€™s rather slow and inflexible, so weâ€™ll write our own function based on fastcoreâ€™s handy dict2obj, which makes all keys available as both attrs and keys.\n\nsource\n\n\n\n NbCell (idx, cell)\n\ndict subclass that also provides access to keys as attrs\nWe use an AttrDict subclass which has some basic functionality for accessing notebook cells.\n\nsource\n\n\n\n\n dict2nb (js=None, **kwargs)\n\nConvert dict js to an AttrDict,\nWe can now convert our JSON into this nbclient-compatible format, which pretty prints the source code of cells in notebooks.\n\nminimal = dict2nb(minimal_txt)\ncell = minimal.cells[1]\ncell\n\n{ 'cell_type': 'code',\n  'execution_count': None,\n  'idx_': 1,\n  'metadata': {},\n  'outputs': [ { 'data': {'text/plain': ['2']},\n                 'execution_count': None,\n                 'metadata': {},\n                 'output_type': 'execute_result'}],\n  'source': '# Do some arithmetic\\n1+1'}\n\n\nThe abstract syntax tree of source code cells is available in the parsed_ property:\n\ncell.parsed_(), cell.parsed_()[0].value.op\n\n([&lt;ast.Expr&gt;], &lt;ast.Add&gt;)\n\n\n\nsource\n\n\n\n\n read_nb (path)\n\nReturn notebook at path\nThis reads the JSON for the file at path and converts it with dict2nb. For instance:\n\nminimal = read_nb(minimal_fn)\nstr(minimal.cells[0])\n\n\"{'cell_type': 'markdown', 'metadata': {}, 'source': '## A minimal notebook', 'idx_': 0}\"\n\n\nThe file name read is stored in path_:\n\nminimal.path_\n\n'../tests/minimal.ipynb'"
  },
  {
    "objectID": "nbio.html#creating-a-notebook",
    "href": "nbio.html#creating-a-notebook",
    "title": "nbio",
    "section": "Creating a notebook",
    "text": "Creating a notebook\n\nsource\n\nnew_nb\n\n new_nb (cells=None, meta=None, nbformat=4, nbformat_minor=5)\n\nReturns an empty new notebook\nUse this function when creating a new notebook. Useful for when you donâ€™t want to create a notebook on disk first and then read it.\n\nsource\n\n\nmk_cell\n\n mk_cell (text, cell_type='code', **kwargs)\n\nCreate an NbCell containing text\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntext\n\n\nsource attr in cell\n\n\ncell_type\nstr\ncode\ncell_type attr in cell\n\n\nkwargs\n\n\n\n\n\n\n\nmk_cell('print(1)', execution_count=0)\n\n{ 'cell_type': 'code',\n  'directives_': {},\n  'execution_count': 0,\n  'idx_': 0,\n  'metadata': {},\n  'source': 'print(1)'}"
  },
  {
    "objectID": "nbio.html#writing-a-notebook",
    "href": "nbio.html#writing-a-notebook",
    "title": "nbio",
    "section": "Writing a notebook",
    "text": "Writing a notebook\n\nsource\n\nnb2dict\n\n nb2dict (d, k=None)\n\nConvert parsed notebook to dict\nThis returns the exact same dict as is read from the notebook JSON.\n\nminimal_fn = Path('../tests/minimal.ipynb')\nminimal = read_nb(minimal_fn)\n\nminimal_dict = _read_json(minimal_fn)\nassert minimal_dict==nb2dict(minimal)\n\n\nsource\n\n\nnb2str\n\n nb2str (nb)\n\nConvert nb to a str\nTo save a notebook we first need to convert it to a str:\n\nprint(nb2str(minimal)[:45])\n\n{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n\n\n\nsource\n\n\nwrite_nb\n\n write_nb (nb, path)\n\nWrite nb to path\nThis returns the exact same string as saved by Jupyter.\n\ntmp = Path('tmp.ipynb')\ntry:\n    minimal_txt = minimal_fn.read_text()\n    write_nb(minimal, tmp)\n    assert minimal_txt==tmp.read_text()\nfinally: tmp.unlink()\n\nHereâ€™s how to put all the pieces of execnb.nbio together:\n\nnb = new_nb([mk_cell('print(1)')])\npath = Path('test.ipynb')\nwrite_nb(nb, path)\nnb2 = read_nb(path)\nprint(nb2.cells)\npath.unlink()\n\n[{'cell_type': 'code', 'metadata': {}, 'source': 'print(1)', 'idx_': 0}]"
  }
]